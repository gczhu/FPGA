##数字逻辑设计课程设置微指令

- **寄存器**分类:
  **R0~R7**:**通用寄存器**  可以存储一个**16-bit**的二进制数据
  **n,z,p**:**状态寄存器**
  **IP**:**指令寄存器**
- **ISA**:(共16组指令)
    - 算数操作：
      - `ADD`:
        机器码:`0000`
        Mode1:`0000` `R1` `R2` `000` `R3` (R1 = R2+R3)

        Mode2:`0000` `R1` `R2` `1` `xxxxx` (R1 = R2+im5) 
      - `NOT`:`0001`
        `0001` `R1` `xxxxxxxxx`
        (R1 = ~R1)
      - `SUB`:`0010`
        Mode1:`0010` `R1` `R2` `000` `R3`
        Mode2:`0010` `R1` `R2` `1` `xxxxx`
      - `AND`:`0011`
        - Mode1:`0011` `R1` `R2` `000` 
        - Mode2:`0011` `R1` `R2` `1` `xxxxx` (对操作的五bit数进行**零拓展**)
      - `OR`: `0100`
        与AND指令类似
      - `XOR`:`0101`
        与AND指令类似
      - `MUL`:`0110`
        `0110` `R1` `R2` `000` `R3` (R1=R2*R3)
        `0110` `R1` `R2` `1` `xxxxx` 
      - `DIV`:`0111`
        与MUL类似，整除运算，将余数保存在**R6**中
      - `SHL`:`1000`(左移)
        `1000` `R1` `1` `xxxxxxxx` (**逻辑左移**)
        `1000` `R1` `0` `xxxxxxxx` (**算数左移**) 
      - `SHR`:`1001`(右移)
        与`SHL`类似
      - `CMP`:`1010`
        与`SUB`类似，进行一次减法操作但**不改变**最终操作的寄存器的值，作用是对**n,z,p**通过这次运算进行改变
    - 传输操作:
      - `LD`:`1011`
        `1011` `R1` `1` `R2` `xxxxx` (R1 <= R2)
        `1011` `R1` `0` `xxxxxxxx` (对零拓展的八位数进行传递)
    - 流程控制操作:
      - `BR`:`1100`
        - `1100` `nzp` `0` `im8`   
            如果当前的n,z,p满足设定的n,z,p那么跳转到 **[IP]+im8**
        - `1100` `nzp` `1` `im8`
            跳转到 **[IP]-im8**  
      - `JMP`:`1101`
            - `1101` `1` `Rx` `im8`
                直接跳转到 **[Rx]+im8**
            - `1101` `000` `1` `im8`
                直接跳到 **[IP]+im8**
            - `1101` `000` `0` `im8`
                跳到 **[IP]-im8** 
      - `CALL`:`1110` (函数调用)
            - `1110` `1` `Rx` `im8`
                函数的开始位置在 **[Rx]+im8**,跳转时,将**IP+1**存储在**R7** 
            - `1110` `000` `1` `im8`
            - `1110` `000` `0` `im8`     
      - `RET`:`1111`
            `1111` `xxxx_xxxx_xxxx_xxxx`
            返回[R7]对应的指令进行执行 



